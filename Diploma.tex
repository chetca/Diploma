\documentclass[a4paper,14pt]{extreport}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{eqnarray}
\usepackage{color,colortbl}
\definecolor{Gray}{gray}{0.9}
\linespread{1.3}
\parindent=1cm
\usepackage[left=3cm, right=1.5cm, top=2cm, bottom=2cm, bindingoffset=0cm]{geometry}
\usepackage{indentfirst}
\usepackage{url}
\makeatletter
\usepackage{tocloft}

\renewcommand{\cftaftertoctitle}{\mbox{}\hfill \\ \mbox{}\hfill{\footnotesize Стр.}\vspace{-2.5em}}

\setcounter{tocdepth}{2} % задать глубину оглавления — до subsection включительно
\usepackage{titlesec}
\titleformat{\chapter}[display]{\filcenter}{\large\MakeUppercase{\chaptertitlename} \thechapter}{8pt}{\large\bfseries}{}
\titleformat{\section}{\large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{18pt}
\titlespacing*{\section}{\parindent}{18pt}{18pt}
\titlespacing*{\subsection}{\parindent}{18pt}{18pt}
\renewcommand{\@biblabel}[1]{#1.\hfil}
\renewcommand\contentsname{ОГЛАВЛЕНИЕ}
\renewcommand\bibname{СПИСОК ЛИТЕРАТУРЫ}
\oddsidemargin=0 cm
\textwidth=16 cm
\textheight=24 cm
\topmargin=0 cm
\headheight=0 cm
\headsep=0 cm

\parindent=0.5 cm

\makeatletter
\renewcommand{\@biblabel}[1]{#1.}
\makeatother


\begin{document}
\begin{titlepage}
\begin{center}
\large
МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РФ

БУРЯТСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ

Институт математики и информатики

Кафедра прикладной математики

\vspace{2 cm}

\textsc{Выпускная квалификационная работа}

\vspace{1.5 cm}

{\LARGE Кроссплатформеное приложение для 3D-визуализации\\
2D-модели плана помещения\\
методом бросания лучей}
\end{center}

\vspace{3 cm}
\begin{table}[h!]
\begin{tabular}{p{0.5\linewidth}l}
\hfill Выполнил :     & студент 4 курса группы 05230\\
                             & Шорников Александр Евгеньевич\\
\hfill Научный руководитель: & к.ф.-м.н., ст. преп. \\
                             & Трунин Дмитрий Олегович\\
\hfill Научный консультант:  & асс. каф. ИТ \\
                             & Брагин Александр Фёдорович\\


\end{tabular}
\end{table}


\vspace{\fill}
\vspace{\fill}
\begin{center}
Улан-Удэ \\ 2017
\end{center}
\end{titlepage}


\newpage    %Это оглавление
\setcounter{page}{2}
\tableofcontents{}


\newpage    %Это введение
\addcontentsline{toc}{chapter}{Введение}
\chapter*{ВВЕДЕНИЕ}
\hspace{\parindent}Интерактивные планы помещений - доступный и современный способ разобраться в незнакомом здании.
Сегодня интерактивная карта в отличие от обычной плоской в виде изображения отличается тем, что ее элементами можно
управлять. Пользователь, находясь на странице, может свободно перемещаться по карте, находить объекты, схему прохода
и просматривать информацию. При необходимости элементы карты могут включать в себя помимо реальных физических объектов
(дома, улицы, парки, дороги и т.д.) дополнительно текстовую информацию, видеозаписи и ссылки на сайты. \\

К таким интерактивным планам предъявляются весьма суровые системные требования: поскольку они предназначены
для самых разных платформ, и должны запускаться не только на можных десктопах, на и на мобильных устройствах, слабых
нодах типа Raspberry Pi, встраивымх системах типа Arduino, а так же крутиться на сайтах. Не на всех из вышеперечисленых
платформ может запускаться стандартная для современных 3D-визуализаций библиотека OpenGL(или WebGL в случае сайтов). \\

Для построения трехмерной визуализации выбран метод бросания лучей. Данный метод, являясь одним из простейших для трехмерной
отрисовки, имеет ряд свойств согласующихся с задачами проекта: малую вычислительную сложность и простую реализацию без
использования готовых библиотек трехмерной графики. Плюсами данного метода так же является то, что метод работает с
плоской двумерной моделью помещения. То есть для визуализации помещения не надо строить полностью трёхмерную карту для
рендеринга - достаточно дать плоскую карту.\\

Метод бросания лучей (англ. Raycasting, рейкастинг) - это один из методов рендеринга в компьютерной графике, при котором 
изображение строится на основе замеров пересечения лучей с визуализируемой поверхностью.Грубо говоря, из точки обзора 
бросается множество лучей, каждый из которых пересекает какой-нибудь отрезок на карте или вообще ничего не пересекает. 
На экране эти точки пересечения отображаются как вертикальные отрезки, рассчитанные от расстояния до визуализируемой 
поверхности. Если точки пересечения нет, то длина вертикального отрезка равна нулю, то есть вырисовывается горизонт.\\


\textbf{Цель}: cоздание кроссплатформеного псевдотрёхмерного движка для 3D визуализации здания по 2D плану.\\

\textbf{Задачи}:\\
 --Модификация алгоритма рейкастинга для вещественных координат;\\
 --Разработка математической модели для рейкастового рендерера;\\
 --Изучение и освоение технологии кросс-компиляции Cheerp;\\

 \textbf{Объектом} исследования является
 задача построения псевдотрёхмерной картинки.\\

 \textbf{Предметом} исследования является
 изучение основных принципов построения псевдотрёхмерной картинки
 методом бросания лучей.\\


\newpage    %1 глава
\chapter{Постановка задачи}

\hspace{\parindent}Итак, перед нами встала задача: создание интерактивного плана помещения методом бросания лучей. 





\newpage    %2 глава
\chapter{Математическая модель}
\section{Способ представления карты}
\hspace{\parindent} Поскольку метод бросания лучей работает с двумерной моделью помещения, необходимо было придумать способ
представления карты для его адекватного считывания подпрограммой считывания уровня и представления функцией обработки. Для
классического рейкастинга уровень представляет собой двумерный массив, где значение каждого элемента массива является квадратом
мира. Если значение ячейки равно 0, то квадрат оказывается пустым, и через него можно пройти. Если же значение больше 0,
квадрат представляет собой стену определённого цвета или текстуры.\\

Для нашего проекта мы изменили алгоритм метода бросания лучей для работы в вещественных координатах. Благодаря этому мы избавились
от ограничений старого задания уровней. Все графические примитивы на карте мы стали обозначать отрезками задаваемыми двумя
вещественными точками, благодаря чему размер карты стал ограничиваться только ресурсами платформ, а так же увеличилась точность
самого рендеринга карты.\\

Для того что бы представить карту каждого этажа в уровне нашего движка необходимо составить модель этого этажа. Как уже говорилось
выше, каждый из графических примитивов в карте задаётся отрезком. И для представления карты внутри программы мы можем создать $C++$-класс,
описывающий тип данных отрезков в качестве совокупности координат $(x_1,y_1)-(x_2,y_2)$, а так же флага принадлежности текстуры к
данному отрезку. Таким образом мы полностью описываем программно уровень карты.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=16cm]{levelScan}\\
\caption{Обработанное изображение 2 этажа 1 корпуса БГУ}
\end{center}
\end{figure}

Теперь для задания необходимого изображения этажа в карту можно представить её в векторном формате $SVG$. $SVG$ (от англ. Scalable
Vector Graphics — масштабируемая векторная графика) — язык разметки масштабируемой векторной графики, предназначеный для описания
двумерной векторной и смешанной векторно/растровой графики в формате $XML$. Выбор пал имеенно на этот формат, поскольку внутрене формат
$SVG$ представляет собой $XML$-документ, содержащий помимо встроеной разметки координаты точек котрезков. Необходимо было только написать
парсер для фильтрации полезной информации из $SVG$. Пример внутренего содержания $SVG$:\\

\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8"?>
<!-- 2017-04-04 23:45:02 Generated by QCAD SVG Exporter -->
<svg width="460mm" height="191mm" viewBox="0 0 460 191"
version="1.1" xmlns="http://www.w3.org/2000/svg"
style="stroke-linecap:round;stroke-linejoin:round;fill:none">
    <g transform="scale(1,-1)">
        <!-- Line -->
        <path d="M208,-65 L208,-112 "
        style="stroke:#000000;stroke-width:0.25;"/>
        <!-- Line -->
        <path d="M212,-112 L212,-65 "
        style="stroke:#000000;stroke-width:0.25;"/>
        <!-- Line -->
        <path d="M180,-2 L278,-2 "
        style="stroke:#000000;stroke-width:0.25;"/>
        <!-- Line -->
        <path d="M278,-2 L278,-61 "
        style="stroke:#000000;stroke-width:0.25;"/>
        <!-- Line -->
        <path d="M236,-61 L236,-65 "
        style="stroke:#000000;stroke-width:0.25;"/>
    </g>
</svg>
\end{lstlisting}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=16cm]{levelSvg}\\
\caption{Векторное представление изображения карты}
\end{center}
\end{figure}

В итоге, общая задач оцифрования уровня карты сводится к сканированию или простому фотографированию пожарного плана
помещения, перевод данного изображения в векторный формат $SVG$, редактирование получившегося изображения при необходимости
и "скармливание" получившегося файла программе считывания уровня. Получение векторное изображение представляет собой уже
размеченый $xml$-документ, который подпрограмма считывания уровня просто парсит, вычленяя необходимую информацию в виде
координат точек отрезков.\\

Для удобства редактирования готовых $SVG$ - файлов мы освоили систему автоматизированного проектирования(САПР, англ. CAD) 
$QCad$. $QCad$ — 2-мерная САПР с открытым исходным кодом, предназначенная для создания чертежей. Работает под операциооыми 
системами $Windows$, $Mac~OS~X$ и на $*nix$ системах. $QCad$ предоставляет различные инструменты для черчения. Многие 
концепции интерфейса и приемы работы схожи с $AutoCAD$. $QCad$ использует формат $DXF$ для сохранения и импорта чертежей по 
умолчанию, однако в профессиональной версии имеет также поддержку $DWG$ и импорт/экспорт в $SVG$. 

\begin{figure}[h!]
\begin{center}
\includegraphics[width=16cm]{QCad}\\
\caption{План 2 этажа ИМИ БГУ в QCad}
\end{center}
\end{figure}

\newpage
\section{Рейкастинг как алгоритм отрисовки}
\hspace{\parindent} Итак, в общем случае у нас на карте задан уровень в виде множества отрезков, а также задана точка,
интерпретирующая положение камеры на карте. Также задан угол обзора, показывающий какие сегменты попали в наблюдение
камеры.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=8cm]{1}\\
\caption{Общий случай описания карты}
\end{center}
\end{figure}

Вектор описывающий положение камеры назовём $\overline{pos}$, а вектором $\overline{dir}$ назовем направление угла обзора.
Длина этого вектора не будет влиять на угол обзора.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=8cm]{2}\\
\caption{Задание векторов}
\end{center}
\end{figure}

При помощи оценивания знака векторного произведения определяется принадлежность сегмента к углу обзора.
Из местоположения наблюдателя (вектор $\overline{pos}$) через каждую точку отрезка экрана, представляющую собой одну
колонку пикселей на мониторе, проводятся  лучи. Их количество равно горизонтальному разрешению экрана. Расстояние
между точками на отрезке равно полутора длинам вектора $\overline{dir}$ деленное на горизонталь разрешения экрана.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=8cm]{3}\\
\caption{Бросание лучей}
\end{center}
\end{figure}

Далее для каждой точки рассчитывается присутствие пересечения луча с сегментами по формуле Краммера и расчитывается
расстояние по лучу до препятствия. В соответствии с полученым расстоянием отображаются линии которые формируют стены.
Длина линии обратно пропорциональна найденному расстоянию. Т.е. чем дальше от нас объект, тем он меньше. Эти линии
формируют стены.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=8cm]{4}\\
\caption{Формирование изображения}
\end{center}
\end{figure}

К сожалению, при бросании луча из одной точки (точки где находится наблюдатель) возникает так называемый “эффект рыбьего
глаза”, или широкоугольного объектива. Это происходит потому что расстояние пройденное по лучу, когда один конец луча
неподвижен, а другой скользит вдоль прямой линии, изменяется по квадратичному закону относительно расстояния пройденного
вдоль экрана.  В результате этого границы стен на изображении описываются кривой второго порядка.  Если мы хотим избежать
этого эффекта, то нам нужно добиться того, чтобы расстояние пройденной лучом изменялось линейно от расстояния пройденного
вдоль экрана. Для этого достаточно пускать лучи перпендикулярно экрану.  Этого можно добиться минимальными изменениями в
алгоритме, всего лишь изменив параметры передаваемые подпрограмме по расчету расстояния - всего лишь умножив получение
расстояние до пересечения на косинус угла между лучом и логическим экраном.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=8cm]{5}\\
\caption{Избавление от "эффекта рыбьего глаза"}
\end{center}
\end{figure}

\newpage
\section{Алгоритм текстурирования}
\hspace{\parindent} При нанесении текстур алгоритм рейкастинга работает практически такая же, но в конце необходимо
произвести несколько дополнительных вычислений текстуры; кроме того, петля в направлении у должна пройти через каждый
пиксель для определения того, какой тексель (пиксель текстуры) данной текстуры необходимо использовать в этот раз.\\

Вертикальные полосы на этот раз нельзя нарисовать с помощью вертикальной командной линии. Вместо этого, каждый пиксель
необходимо рисовать отдельно. Лучший способ - использовать в этот раз карту 2D в качестве буфера экрана, и сразу же
копировать ее на экран.\\

Конечно же, нам необходим собственно, сам набор текстур, и поскольку функция $makeColumn$, которая наносит текстуры,
работает с отдельными целыми значениями для цветов (вместо 3-х отдельных байтов для R, G и B), текстуры хранятся также
в формате $RGB$.\\

Ширина и высота экрана для текстур определяется в самом начале, поскольку нам нужна одна и та же величина для функции
экрана и для создания буфера экрана. Кроме того, новыми являются текстура ширины и высоты, определяемые здесь. Очевидно,
это - ширина и высота в текселях (элементах) текстур.\\

Буфер экрана и наборы текстур - это набор динамических массивов-векторов $STD$ ($std::vectors$). Каждая из текстур обладает
определенными показателями ширины и высоты (в пикселях). В придуманном нами механизме рейкастинга текстуры могут иметь
неограниченный размер, и ограничиваются только весом, ограничением времени и скоростью взаимодействия с ними. Наиболее
оптимальным размером текстур оказался 512х512 пикселей, поскольку такое разрешение даёт достаточное качество картинки без
замедления FPS(частоты смены кадров).\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=8cm]{Textures_1}\\
\caption{Неоптимизованное текстурирование}
\end{center}
\end{figure}

Обычно сами текстуры отрисовываются в виде горизонтальных строк пикселей, но в случае рейкастинга, текстуры изображаются в
виде вертикальных линий. Таким образом, чтобы оптимально использовать кэш центрального процессора, а также избежать пропусков
страниц (avoid page misses), более эффективным может оказаться хранение текстур в памяти в виде набора вертикальных полос
вместо горизонтальных строк пикселей. Для этого после генерирования текстур необходимо поменять их значения $x$ и $y$.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=8cm]{Textures_2}\\
\caption{Оптимизованное текстурирование}
\end{center}
\end{figure}

\newpage
\section{Паттерн для интерактивного взаимодействия}
\hspace{\parindent} Для передвижения в среде полученого движка используется метод сдвига координат. Его суть банальна и сводится к
следующим геометрическим манипуляциям: изменению координат $x$ и $y$ камеры на карте, изменения угла поворота камеры, замеры скорости
перемещения камеры по пространству уровня для спидрана(англ. Speed Run - скоростное перемещение). Скорость перемещения камеры, а равно
и игрока изменяется на константную величину, регулируя которую в файле конфигурации меняем скорость перемещения по карте.\\

Для передвижения по карте необходимо определить угол обзора относительно координатной оси, и, в зависимости от него изменить на
соответствующий коэфициент координаты  $x$ и $y$. В нашем движке это определяется так: заранее в классе игрока Player определяется
точка местоположения игрока $pos$ и угол $dir$, задающийся нулём, что будет означать что камера смотрит точно по направлению оси $Y$. Так же
задаются переменные $dx$ и $dy$, определяющие изменение координат камеры, а так же переменную $ddir$, которая определяет изменение угла,
математический смысл которой $\Delta dir$. \\

Функция описывающая изменение координат называется $Update$. При вызове этой функции, которая получает новые координаты в зависимости от
времени изменения кардров, движения или отсутствия движения камеры, определяются изменения $dx$ и $dy$ и добавляются с определённой
задержкой к основным координатам камеры, для получения плавного передвижения, а так же прибавляется изменение угла в зависимости от
времени. После вышеперечисленых манипуляций переменные $dx$, $dy$ и $ddir$ обнуляются. В коде это определяется так: \\

\begin{lstlisting}
void Player::update(double &time) {
    pos.setX(pos.x() + dx*time*0.1);
    pos.setY(pos.y() + dy*time*0.1);
    dir += (ddir*time*(-0.00001));
    ddir=0;
    dx=0;
    dy=0;
    time = 0;
}
\end{lstlisting}

Переменные $dx$ и $dy$ изменяются в части кода, отвечающей за интерактивное воздействие через нажатие клавиш и повороты мышью.
Изменение угла зависит от поворота вектора $\overline{dir}$, который можно описать следующим шаблоном:\\

\begin{equation*}
\begin{vmatrix}
cos(\alpha) & -sin(\alpha)\\
sin(\alpha) & cos(\alpha)
\end{vmatrix}
\end{equation*}

Развёртка клавиатурных сочетаний была выбрана стандартная игровая расстановка $WASD$, для лучшей адаптации. При нажатии клавиши
$W$ камера должна двинуться вперёд. Изменение координат $dx$ и $dy$ фиксируется следующим образом:\\

\begin{lstlisting}
 if (event->key() == Qt::Key_W) {
        RP->player->setDX(cos(RP->player->getDir()));
        RP->player->setDY(sin(RP->player->getDir()));
 }
\end{lstlisting}

При нажатии клавиши $S$ камера должна двинуться назад. Изменение координат $dx$ и $dy$ фиксируется следующим образом:\\

\begin{lstlisting}
 if (event->key() == Qt::Key_S) {
        RP->player->setDX(-cos(RP->player->getDir()));
        RP->player->setDY(-sin(RP->player->getDir()));
 }
\end{lstlisting}

При нажатии клавиши $D$ камера должна повернуться направо, и широта угла поворота определяется длительностью нажатия.
Изменение координат $dx$ и $dy$ фиксируется следующим образом:\\

\begin{lstlisting}
  if (event->key() == Qt::Key_D) {
        RP->player->setDX(sin(RP->player->getDir()));
        RP->player->setDY(-cos(RP->player->getDir()));
 }
\end{lstlisting}

При нажатии клавиши $A$ камера должна двинуться повернуться направо, и широта угла поворота определяется длительностью нажатия.
Изменение координат $dx$ и $dy$ фиксируется следующим образом:\\

\begin{lstlisting}
 if (event->key() == Qt::Key_A) {
        RP->player->setDX(-sin(RP->player->getDir()));
        RP->player->setDY(cos(RP->player->getDir()));
 }
\end{lstlisting}

При отпускании клавиш изменения прекращаются, и координаты не меняются. Всё это проделывается каждый раз для каждого фрейма(кадра).

\newpage    %3 глава
\chapter{Реализация}
\section{Инструментарий}
\hspace{\parindent} Для создания проекта был выбран язык программирования \\$C++`14$ с фреймворком $Qt~5.8$. $Qt$ это кроссплатформеный 
инструментарий для разработки ПО на языке $C++$, в данной редакции используется язык $C++$ в редакции $ISO/IEC~JTC1$ (полное название: 
$ International~\\Standard~ISO/IEC~14882:2014(E)~Programming~Language~C++$). \\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=15cm]{Qt}\\
\caption{Написание кода в Qt}
\end{center}
\end{figure}

Qt пoзвoляет зaпуcкaть нaпиcaннoе c егo пoмoщью ПО в
бoльшинcтве coвpеменных oпеpaциoнных cиcтем путём пpocтoй кoмпиляции пpoгpaммы для кaждoй oc без изменения иcхoднoгo кoдa. Включaет
в cебя вcе ocнoвные клaccы, кoтopые мoгут пoтpебoвaтьcя пpи paзpaбoтке пpиклaднoгo пpoгpaммнoгo oбеcпечения, нaчинaя oт элементoв
гpaфичеcкoгo интеpфейca и зaкaнчивaя клaccaми для paбoты c cетью, бaзaми дaнных и $XML$. $Qt$ являетcя пoлнocтью oбъектнo-opиентиpoвaнным,
легкo pacшиpяемым и пoддеpживaющим технику кoмпoнентнoгo пpoгpaммиpoвaния. oтличительнaя ocoбеннocть $Qt$ oт дpугих библиoтек -
иcпoльзoвaние $Meta~Object~Compiler~(MOC)$. $MOC$ - компилятор - это пpедвapительная cиcтема oбpaбoтки иcхoднoгo кoдa. 
$MOC$ пoзвoляет вo мнoгo paз увеличить мoщь библиoтек, ввoдя тaкие пoнятия, кaк cлoты и cигнaлы. Кpoме тoгo, этo пoзвoляет 
cделaть кoд бoлее лaкoничным. Утилитa $MOC$ ищет в зaгoлoвoчных фaйлaх нa C++ oпиcaния клaccoв, coдеpжaщие мaкpoc $Q\_OBJECT$, и 
coздaёт дoпoлнительный иcхoдный фaйл нa $C++$, coдеpжaщий метaoбъектный кoд.\\

Для переноса общей части на $JavaScript$ был использован кросс-компилятор $C++$ в $JavaScript$ под названием $Emscripten$.
$Emscripten$ — компилятор из $LLVM$ байт-кода в $JavaScript$. $C/C++$ код может быть скомпилирован в $LLVM$ байт-код с
помощью компилятора $Clang$. Некоторые другие языки так же имеют компиляторы в $LLVM$ байт-код. $Emscripten$ на основе
байт-кода генерирует соответствующий $JavaScript$-код, который может быть выполнен любым интерпретатором $JavaScript$,
например современным браузером. $Emscripten$ предоставляет: $emconfigure$ – утилита настройки окружения и последующего запуска
$./configure$; $emmake$ – утилита для настройки окружения и последующего запуска $make$; $emcc$ – компилятор $LLVM$ в $JavaScript$. \\

Сам код на $Qt$ был написан написан максимально неплатформозависимым, следующим стандартам языка и не использующим нестандартные 
библиотеки, для того что бы написаный код был без проблем перенесён на $JavaScript$. Для достижения такого эффекта даже была перенесена 
и в ручную доделана библиотека из $Boost$, использующаяся в геометрии для просчёта расстояния, пройденого лучём, а так же для работы с 
сегментами. Новые библиотеки получили имя $ssegment.h$ и $mygeom.h$.\\

Для автоматической сборки проекта и компиляции использована утилита $CMake$. $CMake$ - это универсальная кроссплатформенная утилита
для автоматической сборки программы из исходных кодов. При этом сама $CMake$ непосредственно сборкой кода не занимается, а выступает
в качестве front-end`a для back-end компилятора. И в итоге для общей сборки проекта необходим скрипт сборки для $CMake$, который
выглядит следующим образом:\\

\begin{lstlisting}
cmake -G"MinGW Makefiles" -DCMAKE_TOOLCHAIN_FILE=
C:\cheerp\share\cmake\Modules\CheerpToolchain.cmake
../segments && mingw32-make
\end{lstlisting}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=15cm]{cmake}\\
\caption{Пример компиляции при помощи CMake}
\end{center}
\end{figure}


Подобного рода скрипты позволяют скомпилировать проект и сразу в нативную версию, и в версию для web-приложения с условием готового
платформозависимого канваса и буффера кадров для странички $HTML$. Выходной $JavaScript$-файл встраивается на заранее установленную
страничку автоматически.

\newpage
\section{Организация работы над проектом}
\hspace{\parindent}  

\newpage
\section{Структура проекта (UML)}
\hspace{\parindent} 

\newpage
\section{Реализация на целевых платформах}
\hspace{\parindent} Поскольку современный человек предпочитает универсальные механизмы для любых платформ, мы так же озадачили себя
кроссплатформеностью одного и того же кода, причём на таких казалось бы несовместимых платформах как web и
нативная платформа(десктоп и мобильное приложение). Для достижения кроссплатформы на любой десктопной
операционной системы, в разработке был применён язык $C++`14$ с фреймворком
$Qt~5.8.0$. Использование именно этой среды и языка обеспечило полную совместимость как в $*nix$ системах
(в частности, в $MacOS~X$, системах на основе ядра $Linux$, $BSD$ - системах и тд), так и в среде $Windows$.
Так же фреймворк Qt позволяет с лёгкостью перекомпилировать тот же самый код без особых изменений на любое
$Android$ - устройство и устройство с $iOs$, например $iPhone$, что весьма актуально ввиду всеобщей
распространённости таких гаджетов. \\

Однако, с платформой Web для встраивания на сайты пришлось повозиться. Любая web-страничка в Интернете представляет
собой совокупность документа $HTML$, каскадную страницу стилей $CSS$, скриптовую часть на языке $JavaScript$ и внутренее
содержание в виде текста, документов содержащих в себе картинки, аудиоокнтент, видеоконтент, мультимедиа, апплеты
и гиперссылки на другие страницы. И для реализации на сайте нашего приложения необходимо было создать скриптовый
апплет. Ввиду абсолютной несовместимости web-платформы c языком $C++$ в качестве скриптового языка для встраиваемых апплетов,
необходимо было перенести реализацию на язык $JavаScript$ с сохранением работоспособности десктопной версии. \\

Для решения этой проблемы мы разделили кодовую базу, сделав общей часть непосредственно решающую задачу, и отделив код
специфичный для каждой из платформ. Код решающий задачу оперирует абстрактными классами канвы ($Core::Canvas$) и буфера
($Core::ImageBuffer$), которые в свою очередь конкретизируются для каждой платформы.\\

В итоге, в общую часть у нас вошло: Алгоритм рейкастинга, Представление карт уровней, Абстракции канвы и буфера кадров.
И части для каждой платформ вошли конкретные реализации канвы и буфера кадров. Сейчас специальная часть для платформ
занимают лишь $30\%$ от общей кодовой базы, и нет причин для увеличения этой части с ростом проекта.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=16cm]{web-ds}\\
\caption{Разделение конкретных реализаций}
\end{center}
\end{figure}

Для переноса общей части на $JavaScript$ был использован кросс-компилятор $C++$ в $JavaScript$ под названием $Emscripten$, 
как было описано выше.

В общем итоге одна кодовая база делится на два подвида - для нативной платформы версия с $Qt$ и для Web-платформы версия 
$JavaScript$. Подобные проекты с уникальной кодовой базой под разные платформы крайне редки в наше время, и это уникальная 
разработка для нас. 

\newpage
\section{Внедрение ссылка на сайт ИМИ БГУ}
\hspace{\parindent} 

\newpage
\chapter*{ЗАКЛЮЧЕНИЕ} %ЭТО НЕНУМЕРОВАННЫЙ РАЗДЕЛ
\addcontentsline{toc}{chapter}{Заключение}
\hspace{\parindent} Для рендеринга трёхмерной картинки существует много методов, однако, методов бросания лучей являются одними
из самых простых и быстрых. С его помощью можно быстро и без особых усилий отрендерить псевдотрёхмерную картинку, получить результат
быстро и без больших вычислительных можностей. \\


Итогом всей работы стал готовый кроссплатформеный интерактивный план помещений, который в настоящее время
активно внедряется для использования в ИМИ БГУ, а в дальнейшем распространяется и на весь БГУ. Приложение
является кроссплатформеным и универсальным, и в этом его преимущество. Создание интерактивного плана с
сохранением кроссплатформености - это очень сложная в технологическом смысле задача.\\
Но толкько БГУ не ограничивается применение получегого ПО. Благодаря удобному устройству задания уровней
без проблем можно применить его к любому зданию, необходимо только сделать двумерный план помещения и сформировать текстуры.Во многим,
технология рейкастинга и устарела. С её помощью нельзя сделать картинку "реалистичной", пол и потолок всегда константной высоты,
плохое и малоразмерное текстурирование и тд. Но несмотря на это, моя работа доказало его эффективность и в наше время.\\

\newpage
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Список литературы}
\bibitem{antonova}Антонова Л.В., Бурзалова Т.В. Проективная геометрия : учеб. пособие.— Улан-Удэ : Бурятский государственный университет, 2016 .— 152 с.
\bibitem{straus} Бьерн Страуструп. Язык программирования С++(3 издание). -СПб.: Невский Диалект, 2008. - 504 с.
\bibitem{veldmanter}Вельтмандер П.В. Машинная графика. Основные алгоритмы. Книга 2.  – Новосибирск: НГУ, 1997. -197 с.
\bibitem{kotov}Котов Ю. В. Как рисует машина. — М.: Наука, 1988. — 224 с.
\bibitem{laslo}Ласло М. Вычислительная геометрия и компьютерная графика на C++. — М.: БИНОМ, 1997. — 304 с.
\bibitem{laslo}Макс Шлее. Qt 5.3. Профессиональное программирование на C++. -СПб.: БВХ-Петербург, 2015.
\bibitem{nikulin}Никулин Е. А. Компьютерная геометрия и алгоритмы машинной графики - СПб.:  БХВ-Петербург, 2003. - 554 с.
\bibitem{pavlidis}Павлидис Т. Алгоритмы машинной графики и обработки изображений: Пер. с англ. - М.: Радио и связь, 1986. – 400 с.
\bibitem{rodgers}Роджерс Д. Алгоритмические основы машинной графики. — М.: Мир, 1989. — С. 50-54
\bibitem{schirkov}Чириков С. В. Алгоритмы компьютерной графики (Методы растрирования кривых). Учебное пособие — СПб: СПбГИТМО(ТУ), 2001. — 120 с.
\bibitem{jozeph}Joseph O'Rourke. Computational Geometry in C. — Cambridge University Press, 1998. — 362 с.
\bibitem{start1}Kushner, David (2004-05-11). Masters of Doom: How Two Guys Created an Empire and Transformed Pop Culture. Random House.
\bibitem{start2}Kent, Steven L. (2010-06-16). The Ultimate History of Video Games. Three Rivers Press.
\bibitem{start3}Slaven, Andy (2002-07-01). Video Game Bible, 1985-2002. Trafford Publishing
\bibitem{lode}Lode's Computer Graphics Tutorial. 2007. URL: http://lodev.org/cgtutor/index.html
\bibitem{java}Making a Basic 3D Engine in Java. 2009. URL: http://www.instructables.com/id/Making-a-Basic-3D-Engine-in-Java/
\bibitem{raycast}RAYCASTING - сделай себе немного DOOM'a. 2004. URL: http://zxdn.narod.ru/coding/ig5ray3d.htm
\end{thebibliography}

\newpage
\appendix
\addcontentsline{toc}{chapter}{Приложение 1}
\begin{flushright}
\large \textit{П~Р~И~Л~О~Ж~Е~Н~И~Е~1}
\end{flushright}
\begin{center}
\large \textbf{Программный код приложения для реализации метода бросания лучей}
\end{center}

\end{document} 