\documentclass[a4paper,14pt]{extreport}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{eqnarray}
\usepackage{color,colortbl}
\definecolor{Gray}{gray}{0.9}
\linespread{1.3}
\parindent=1cm
\usepackage[left=3cm, right=1.5cm, top=2cm, bottom=2cm, bindingoffset=0cm]{geometry}
\usepackage{indentfirst}
\usepackage{url}
\makeatletter
\usepackage{tocloft}

\renewcommand{\cftaftertoctitle}{\mbox{}\hfill \\ \mbox{}\hfill{\footnotesize Стр.}\vspace{-2.5em}}

\setcounter{tocdepth}{2} % задать глубину оглавления — до subsection включительно
\usepackage{titlesec}
\titleformat{\chapter}[display]{\filcenter}{\large\MakeUppercase{\chaptertitlename} \thechapter}{8pt}{\large\bfseries}{}
\titleformat{\section}{\large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{18pt}
\titlespacing*{\section}{\parindent}{18pt}{18pt}
\titlespacing*{\subsection}{\parindent}{18pt}{18pt}
\renewcommand{\@biblabel}[1]{#1.\hfil}
\renewcommand\contentsname{ОГЛАВЛЕНИЕ}
\renewcommand\bibname{СПИСОК ЛИТЕРАТУРЫ}
\oddsidemargin=0 cm
\textwidth=16 cm
\textheight=24 cm
\topmargin=0 cm
\headheight=0 cm
\headsep=0 cm

\parindent=0.5 cm

\makeatletter
\renewcommand{\@biblabel}[1]{#1.}
\makeatother


\begin{document}
\begin{titlepage}
\begin{center}
\large
МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РФ

БУРЯТСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ

Институт математики и информатики

Кафедра прикладной математики

\vspace{2 cm}

\textsc{Выпускная квалификационная работа}

\vspace{1.5 cm}

{\LARGE Кроссплатформеное приложение для 3D-визуализации\\
2D-модели плана помещения\\
методом бросания лучей}
\end{center}

\vspace{3 cm}
\begin{table}[h!]
\begin{tabular}{p{0.5\linewidth}l}
\hfill Выполнил :     & студент 4 курса группы 05230\\
                             & Шорников Александр Евгеньевич\\
\hfill Научный руководитель: & к.ф.-м.н., ст. преп. \\
                             & Трунин Дмитрий Олегович\\
\hfill Научный консультант:  & асс. каф. ИТ \\
                             & Брагин Александр Фёдорович\\


\end{tabular}
\end{table}


\vspace{\fill}
\vspace{\fill}
\begin{center}
Улан-Удэ \\ 2017
\end{center}
\end{titlepage}


\newpage    %Это оглавление
\setcounter{page}{2}
\tableofcontents{}


\newpage    %Это введение
\addcontentsline{toc}{chapter}{Введение}
\chapter*{ВВЕДЕНИЕ}
\hspace{\parindent}Интерактивные планы помещений - доступный и современный способ разобраться в незнакомом здании.
Сегодня интерактивная карта в отличие от обычной плоской в виде изображения отличается тем, что ее элементами можно
управлять. Пользователь, находясь на странице, может свободно перемещаться по карте, находить объекты, схему прохода
и просматривать информацию. При необходимости элементы карты могут включать в себя помимо реальных физических объектов
(дома, улицы, парки, дороги и т.д.) дополнительно текстовую информацию, видеозаписи и ссылки на сайты. \\

К таким интерактивным планам предъявляются весьма суровые системные требования: поскольку они предназначены
для самых разных платформ, и должны запускаться не только на можных десктопах, на и на мобильных устройствах, слабых
нодах типа Raspberry Pi, встраивымх системах типа Arduino, а так же крутиться на сайтах. Не на всех из вышеперечисленых
платформ может запускаться стандартная для современных 3D-визуализаций библиотека OpenGL(или WebGL в случае сайтов). \\

Для построения трехмерной визуализации выбран метод бросания лучей. Данный метод, являясь одним из простейших для трехмерной
отрисовки, имеет ряд свойств согласующихся с задачами проекта: малую вычислительную сложность и простую реализацию без
использования готовых библиотек трехмерной графики. Плюсами данного метода так же является то, что метод работает с
плоской двумерной моделью помещения. То есть для визуализации помещения не надо строить полностью трёхмерную карту для
рендеринга - достаточно дать плоскую карту.\\

\textbf{Цель}: cоздание кроссплатформеного псевдотрёхмерного движка для 3D визуализации здания по 2D плану.\\

\textbf{Задачи}:\\
 --Модификация алгоритма рейкастинга для вещественных координат;\\
 --Разработка математической модели для рейкастового рендерера;\\
 --Изучение и освоение технологии кросс-компиляции Cheerp;\\

 \textbf{Объектом} исследования является
 задача построения псевдотрёхмерной картинки.\\

 \textbf{Предметом} исследования является
 изучение основных принципов построения псевдотрёхмерной картинки
 методом бросания лучей.\\

\newpage    %1 глава
\chapter{Постановка задачи}
\hspace{\parindent}Итак, перед нами встала задача: создание интерактивного плана помещения методом бросания лучей.
Поскольку современный человек предпочитает универсальные механизмы для любых платформ, мы так же озадачили себя
кроссплатформеностью одного и того же кода, причём на таких казалось бы несовместимых платформах как web и
нативная платформа(десктоп и мобильное приложение). Для достижения кроссплатформы на любой десктопной
операционной системы, в разработке был применён язык $C++`14$ с фреймворком
$Qt~5.8.0$. Использование именно этой среды и языка обеспечило полную совместимость как в $*nix$ системах
(в частности, в $MacOS~X$, системах на основе ядра $Linux$, $BSD$ - системах и тд), так и в среде $Windows$.
Так же фреймворк Qt позволяет с лёгкостью перекомпилировать тот же самый код без особых изменений на любое
$Android$ - устройство и устройство с $iOs$, например $iPhone$, что весьма актуально ввиду всеобщей
распространённости таких гаджетов. \\

Однако, с платформой Web для встраивания на сайты пришлось повозиться. Любая web-страничка в Интернете представляет 
собой совокупность документа $HTML$, каскадную страницу стилей $CSS$, скриптовую часть на языке $JavaScript$ и внутренее 
содержание в виде текста, документов содержащих в себе картинки, аудиоокнтент, видеоконтент, мультимедиа, апплеты 
и гиперссылки на другие страницы. И для реализации на сайте нашего приложения необходимо было создать скриптовый 
апплет. Ввиду абсолютной несовместимости web-платформы c языком $C++$ в качестве скриптового языка для встраиваемых апплетов, 
необходимо было перенести реализацию на язык $JavаScript$ с сохранением работоспособности десктопной версии. \\

Для решения этой проблемы мы разделили кодовую базу, сделав общей часть непосредственно решающую задачу, и отделив код 
специфичный для каждой из платформ. Код решающий задачу оперирует абстрактными классами канвы ($Core::Canvas$) и буфера 
($Core::ImageBuffer$), которые в свою очередь конкретизируются для каждой платформы.\\

В итоге, в общую часть у нас вошло: Алгоритм рейкастинга, Представление карт уровней, Абстракции канвы и буфера кадров. 
И части для каждой платформ вошли конкретные реализации канвы и буфера кадров. Сейчас специальная часть для платформ 
занимают лишь $30\%$ от общей кодовой базы, и нет причин для увеличения этой части с ростом проекта.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=16cm]{web-ds}\\
\caption{Разделение конкретных реализаций}
\end{center}
\end{figure}

Для переноса общей части на $JavaScript$ был использован кросс-компилятор $C++$ в $JavaScript$ под названием $Emscripten$. 
$Emscripten$ — компилятор из $LLVM$ байт-кода в $JavaScript$. $C/C++$ код может быть скомпилирован в $LLVM$ байт-код с 
помощью компилятора $Clang$. Некоторые другие языки так же имеют компиляторы в $LLVM$ байт-код. $Emscripten$ на основе 
байт-кода генерирует соответствующий $JavaScript$-код, который может быть выполнен любым интерпретатором $JavaScript$, 
например современным браузером. $Emscripten$ предоставляет: $emconfigure$ – утилита настройки окружения и последующего запуска 
$./configure$; $emmake$ – утилита для настройки окружения и последующего запуска $make$; $emcc$ – компилятор $LLVM$ в $JavaScript$. \\

Для автоматической сборки проекта и компиляции использована утилита $CMake$. $CMake$ - это универсальная кроссплатформенная утилита 
для автоматической сборки программы из исходных кодов. При этом сама $CMake$ непосредственно сборкой кода не занимается, а выступает 
в качестве front-end`a для back-end компилятора. И в итоге для общей сборки проекта необходим скрипт сборки для $CMake$, который 
выглядит следующим образом:\\

\begin{lstlisting}
cmake -G"MinGW Makefiles" -DCMAKE_TOOLCHAIN_FILE=
C:\cheerp\share\cmake\Modules\CheerpToolchain.cmake 
../segments && mingw32-make
\end{lstlisting}


Подобного рода скрипты позволяют скомпилировать проект и сразу в нативную версию, и в версию для web-приложения с условием готового 
платформозависимого канваса и буффера кадров для странички $HTML$. Выходной $JavaScript$-файл встраивается на заранее установленную 
страничку автоматически.

\newpage    %2 глава
\chapter{Математическая модель}
\section{Способ представления карты}
\hspace{\parindent} Поскольку метод бросания лучей работает с двумерной моделью помещения, необходимо было придумать способ 
представления карты для его адекватного считывания подпрограммой считывания уровня и представления функцией обработки. Для 
классического рейкастинга уровень представляет собой двумерный массив, где значение каждого элемента массива является квадратом 
мира. Если значение ячейки равно 0, то квадрат оказывается пустым, и через него можно пройти. Если же значение больше 0, 
квадрат представляет собой стену определённого цвета или текстуры.\\

Для нашего проекта мы изменили алгоритм метода бросания лучей для работы в вещественных координатах. Благодаря этому мы избавились 
от ограничений старого задания уровней. Все графические примитивы на карте мы стали обозначать отрезками задаваемыми двумя 
вещественными точками, благодаря чему размер карты стал ограничиваться только ресурсами платформ, а так же увеличилась точность 
самого рендеринга карты.\\

Для того что бы представить карту каждого этажа в уровне нашего движка необходимо составить модель этого этажа. Как уже говорилось 
выше, каждый из графических примитивов в карте задаётся отрезком. И для представления карты внутри программы мы можем создать $C++$-класс, 
описывающий тип данных отрезков в качестве совокупности координат $(x_1,y_1)-(x_2,y_2)$, а так же флага принадлежности текстуры к 
данному отрезку. Таким образом мы полностью описываем программно уровень карты.\\

\begin{figure}[h!]
\begin{center}
\includegraphics[width=16cm]{levelScan}\\
\caption{Обработанное изображение 2 этажа 1 корпуса БГУ}
\end{center}
\end{figure}

Теперь для задания необходимого изображения этажа в карту можно представить её в векторном формате $SVG$. $SVG$ (от англ. Scalable 
Vector Graphics — масштабируемая векторная графика) — язык разметки масштабируемой векторной графики, предназначеный для описания 
двумерной векторной и смешанной векторно/растровой графики в формате $XML$. Выбор пал имеенно на этот формат, поскольку внутрене формат 
$SVG$ представляет собой $XML$-документ, содержащий помимо встроеной разметки координаты точек котрезков. Необходимо было только написать 
парсер для фильтрации полезной информации из $SVG$. Пример внутренего содержания $SVG$:\\

\begin{lstlisting}
<?xml version="1.0" encoding="UTF-8"?>
<!-- 2017-04-04 23:45:02 Generated by QCAD SVG Exporter -->
<svg width="460mm" height="191mm" viewBox="0 0 460 191" 
version="1.1" xmlns="http://www.w3.org/2000/svg" 
style="stroke-linecap:round;stroke-linejoin:round;fill:none">
    <g transform="scale(1,-1)">
        <!-- Line -->
        <path d="M208,-65 L208,-112 " 
        style="stroke:#000000;stroke-width:0.25;"/>
        <!-- Line -->
        <path d="M212,-112 L212,-65 " 
        style="stroke:#000000;stroke-width:0.25;"/>
        <!-- Line -->
        <path d="M180,-2 L278,-2 " 
        style="stroke:#000000;stroke-width:0.25;"/>
        <!-- Line -->
        <path d="M278,-2 L278,-61 " 
        style="stroke:#000000;stroke-width:0.25;"/>
        <!-- Line -->
        <path d="M236,-61 L236,-65 " 
        style="stroke:#000000;stroke-width:0.25;"/>
    </g>
</svg>
\end{lstlisting}

\begin{figure}[h!]
\begin{center}
\includegraphics[width=16cm]{levelSvg}\\
\caption{Векторное представление изображения карты}
\end{center}
\end{figure}

В итоге, общая задач оцифрования уровня карты сводится к сканированию или простому фотографированию пожарного плана 
помещения, перевод данного изображения в векторный формат $SVG$, редактирование получившегося изображения при необходимости 
и "скармливание" получившегося файла программе считывания уровня. Получение векторное изображение представляет собой уже 
размеченый $xml$-документ, который подпрограмма считывания уровня просто парсит, вычленяя необходимую информацию в виде 
координат точек отрезков.\\

\newpage  
\section{Рейкастинг как алгоритм отрисовки}

\newpage
\section{Алгоритм текстурирования}

\newpage
\section{Паттерн для интерактивного взаимодействия}

\newpage    %2 глава
\chapter{Реализация}
\section{Инструментарий}

\newpage
\section{Организация работы над проектом}

\newpage
\section{Структура проекта (UML)}

\newpage
\section{Реализация на целевых платформах}

\newpage
\section{Внедрение ссылка на сайт ИМИ БГУ}

\newpage
\chapter*{ЗАКЛЮЧЕНИЕ} %ЭТО НЕНУМЕРОВАННЫЙ РАЗДЕЛ
\addcontentsline{toc}{chapter}{Заключение}

\newpage
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Список литературы}
\bibitem{straus} Бьерн Страуструп. Язык программирования С++(3 издание). -СПб.: Невский Диалект, 2008. - 504 с.
\end{thebibliography}

\newpage
\appendix
\addcontentsline{toc}{chapter}{Приложение 1}
\begin{flushright}
\large \textit{П~Р~И~Л~О~Ж~Е~Н~И~Е~1}
\end{flushright}
\begin{center}
\large \textbf{Программный код приложения для реализации метода бросания лучей}
\end{center}

\end{document} 