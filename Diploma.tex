\documentclass[a4paper,14pt]{extreport}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{eqnarray}
\usepackage{color,colortbl}
\definecolor{Gray}{gray}{0.9}
\linespread{1.3}
\parindent=1cm
\usepackage[left=3cm, right=1.5cm, top=2cm, bottom=2cm, bindingoffset=0cm]{geometry}
\usepackage{indentfirst}
\usepackage{url}
\makeatletter
\usepackage{tocloft}

\renewcommand{\cftaftertoctitle}{\mbox{}\hfill \\ \mbox{}\hfill{\footnotesize Стр.}\vspace{-2.5em}}

\setcounter{tocdepth}{2} % задать глубину оглавления — до subsection включительно
\usepackage{titlesec}
\titleformat{\chapter}[display]{\filcenter}{\large\MakeUppercase{\chaptertitlename} \thechapter}{8pt}{\large\bfseries}{}
\titleformat{\section}{\large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{1em}{}
\titlespacing*{\chapter}{0pt}{-30pt}{18pt}
\titlespacing*{\section}{\parindent}{18pt}{18pt}
\titlespacing*{\subsection}{\parindent}{18pt}{18pt}
\renewcommand{\@biblabel}[1]{#1.\hfil}
\renewcommand\contentsname{ОГЛАВЛЕНИЕ}
\renewcommand\bibname{СПИСОК ЛИТЕРАТУРЫ}
\oddsidemargin=0 cm
\textwidth=16 cm
\textheight=24 cm
\topmargin=0 cm
\headheight=0 cm
\headsep=0 cm

\parindent=0.5 cm

\makeatletter
\renewcommand{\@biblabel}[1]{#1.}
\makeatother


\begin{document}
\begin{titlepage}
\begin{center}
\large
МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РФ

БУРЯТСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ

Институт математики и информатики

Кафедра прикладной математики

\vspace{2 cm}

\textsc{Выпускная квалификационная работа}

\vspace{1.5 cm}

{\LARGE Кроссплатформеное приложение для 3D-визуализации\\
2D-модели плана помещения\\
методом бросания лучей}
\end{center}

\vspace{3 cm}
\begin{table}[h!]
\begin{tabular}{p{0.5\linewidth}l}
\hfill Выполнил :     & студент 4 курса группы 05230\\
                             & Шорников Александр Евгеньевич\\
\hfill Научный руководитель: & к.ф.-м.н., ст. преп. \\
                             & Трунин Дмитрий Олегович\\
\hfill Научный консультант:  & асс. каф. ИТ \\
                             & Брагин Александр Фёдорович\\


\end{tabular}
\end{table}


\vspace{\fill}
\vspace{\fill}
\begin{center}
Улан-Удэ \\ 2017
\end{center}
\end{titlepage}


\newpage    %Это оглавление
\setcounter{page}{2}
\tableofcontents{}


\newpage    %Это введение
\addcontentsline{toc}{chapter}{Введение}
\chapter*{ВВЕДЕНИЕ}
\hspace{\parindent}Интерактивные планы помещений - доступный и современный способ разобраться в незнакомом здании. 
Сегодня интерактивная карта в отличие от обычной плоской в виде изображения отличается тем, что ее элементами можно 
управлять. Пользователь, находясь на странице, может свободно перемещаться по карте, находить объекты, схему прохода 
и просматривать информацию. При необходимости элементы карты могут включать в себя помимо реальных физических объектов 
(дома, улицы, парки, дороги и т.д.) дополнительно текстовую информацию, видеозаписи и ссылки на сайты. \\

К таким интерактивным планам предъявляются весьма суровые системные требования: поскольку они предназначены 
для самых разных платформ, и должны запускаться не только на можных десктопах, на и на мобильных устройствах, слабых 
нодах типа Raspberry Pi, встраивымх системах типа Arduino, а так же крутиться на сайтах. Не на всех из вышеперечисленых 
платформ может запускаться стандартная для современных 3D-визуализаций библиотека OpenGL(или WebGL в случае сайтов). \\

Для построения трехмерной визуализации выбран метод бросания лучей. Данный метод, являясь одним из простейших для трехмерной 
отрисовки, имеет ряд свойств согласующихся с задачами проекта: малую вычислительную сложность и простую реализацию без 
использования готовых библиотек трехмерной графики. Плюсами данного метода так же является то, что метод работает с 
плоской двумерной моделью помещения. То есть для визуализации помещения не надо строить полностью трёхмерную карту для 
рендеринга - достаточно дать плоскую карту.\\

\textbf{Цель}: cоздание кроссплатформеного псевдотрёхмерного движка для 3D визуализации здания по 2D плану.\\

\textbf{Задачи}:\\
 --Модификация алгоритма рейкастинга для вещественных координат;\\
 --Разработка математической модели для рейкастового рендерера;\\
 --Изучение и освоение технологии кросс-компиляции Cheerp;\\

 \textbf{Объектом} исследования является
 задача построения псевдотрёхмерной картинки.\\

 \textbf{Предметом} исследованияявляется
 изучение основных принципов построения псевдотрёхмерной картинки
 методом бросания лучей.\\

\newpage    %1 глава
\chapter{Постановка задачи}
Метод бросания лучей(англ. Raycasting, "Рейкастинг") - это технология получения изображения по модели с помощью компьютерной
программы, позволяющая создавать 3D перспективу в 2D картах\cite{raycast}.
В те времена, когда компьютеры были намного медленнее, чем сейчас, и механизмы 3D невозможно было запустить в реальном времени,
рейкастинг был единственным возможным решением. Рейкастинг может работать очень быстро, поскольку он предполагает только выполнение
необходимых вычислений для каждой вертикальной линии на экране. Самая известная игра с применением рейкастинга - это, конечно же,
компьютерная игра \textit{Wolfenstein 3D}.\\

\textit{Wolfenstein 3D engine} — псевдотрёхмерный игровой движок, разработанный для игры \textit{Wolfenstein 3D},
вышедшей 5 мая 1992 года. Движок разрабатывался преимущественно Джоном Кармаком, главным программистом компании id Software. Движок
\textit{Wolfenstein 3D engine} реализует VGA графику (рейтранслитинговая), звук (WAV и IMF), физику и управление. Написан на Си и ассемблере x86.\\
Возможности компьютеров с процессором Intel 80286, которые были тогда распространены, были крайне ограничены\cite{start2}. Для рендеринга изображения
при помощи рейкастинга в игре \textit{Wolfenstein 3D} движок игры был специальным образом оптимизирован для слабых вычислительных машин.
В результате чего все стены в этой игре имеют одинаковую высоту, и представляют собой взаимно перпендикулярные ячейки 2D сети, как видно на рисунке 1.2:

К сожалению, графические движки на основе технологии рейкастинга слишком слабы, что бы реализовать такие элементы, как лестницы или
прыжки с разницей высот. Независимые графические объекты, свободно перемещающиеся по экрану (противники, внутреигровые объекты и
прочее) представляют собой не трёхмерные объекты, а двухмерные картинки-спрайты. Более поздние игры на этой технологии,
такие как \textit{Doom} и \textit{Duke Nukem 3D} были гораздо более продвинутыми, и
позволяли создавать наклонные стены (поверхности), разницу высот, текстурированные полы и потолки, прозрачные стены и т.д., но в них
 были использованны разные технологии помимо рейкастинга, поэтому в рамках данной курсовой работы они не представляют интереса\cite{start3}.\\

\newpage    %2 глава
\chapter{Математическая модель}
\section{Способ представления карты}
Основная идея рейкастинга состоит в следующем: карта представляет собой 2D-решетку с квадратными ячейками (двухмерный массив),
где значением каждой ячейки может быть равно 0, что означает отсутствие стены, либо положительное число, означающее стену
определенного цвета или текстуры. \\

Каждому значению х на экране (для каждой вертикальной линии на экране) соответствует луч,
который исходит из местонахождения игрока и направление которого зависит от двух критериев: направление взгляда игрока и
координата х на экране. Затем данный луч начинается двигаться вперед по 2D карте до тех пор, пока не упрется в ячейку карты,
которая является стеной. Если он пересечётся со стеной, то будет рассчитываться расстояние от этой точки соприкосновения со
стеной до игрока, которое поможет определить, насколько высоко стену нужно будет переместить на экране: чем дальше распложена
стена, тем меньше будет ее изображение на экране, и наоборот. Это - все 2D расчёты\cite{laslo}. На рисунке 2.2 в ракурсе <<сверху вниз>>
представлены два луча (выделены красным), которые исходят от игрока зеленя точка) и упираются в синюю стену.

Чтобы обнаружить первую стену, которую луч встречает на своем пути, необходимо, чтобы он исходил из точки местоположения
игрока, а затем нужно все время проверять, не находится ли луч внутри стены. Если он оказывается внутри стены (упирается в неё),
цикл можно завершить, рассчитать расстояние и нарисовать стену правильной высоты. Если же луч не упирается в стену,
необходимо продолжать вести его: добавить определённую величину к его положению, в направлении направления данного луча, и
проверить, не находится ли луч в новом положении внутри стены. Проделывать данные действия необходимо до тех пор, пока
луч не коснется стены. \\

Человек может сразу же увидеть, касается ли луч стены, но невозможно сразу же рассчитать, какой именно ячейки луч касается,
используя всего одну формулу, поскольку компьютер может осуществить проверку ограниченного количества положений луча.
Многие рейкастовые движки добавляют постоянную величину к лучу на каждом этапе, но в этом случае существует вероятность
того, что луч может "промахнуться" и не коснуться стены. Например, положение этого красного луча проверялось в каждой красной точке.

Как вы можете видеть на рисунке 2.3, луч проходит прямо через синюю стену, но компьютеру не удалось это определить, поскольку
он осуществлял только проверки красных точек. Чем большее количество положений проверяется, тем менее вероятность того,
что компьютер не определит стену, но тем больше вычислений понадобится выполнить. На рисунке 2.4 показано, что расстояние
между шагами было уменьшено вдвое, и компьютером было определено, что луч проходит через стену, хотя его положение и не совсем верно.\\

Для повышения точности данного метода необходимо бесконечно малое расстояние между точками, и, таким образом, необходимо будет
производить бесконечное количество вычислений. Это неудобно, но, к счастью, существует более подходящая методика, предполагающая
выполнение лишь нескольких вычислений и позволяющая определить каждую из стен. Идея состоит в следующем: проверять факт наличие
луча на каждой из сторон стены. При ширине каждой ячейки, равной 1, каждая из сторон стены будет целым числом, а места между
стенами будут равны некоему числу с цифрами после запятой. В этом случае размер шага не является постоянной величиной, он зависит
от расстояния до следующей стороны ячейки.

Как видно на рисунке 2.5, луч касается стены именно там, где нам это необходимо. В способе используется алгоритм, основанный на
цифровом дифференциальном анализе. Цифровой Дифференциальный Анализ(Digital Differential Analysis, DDA) - скоростной алгоритм, обычно применяемый при использовании
квадратной решётки, позволяющий определить, какие ячейки задевает луч (например, чтобы нарисовать линию на экране, состоящем из
решётки квадратных пикселей)\cite{nikulin}. Таким образом, можно использовать этот метод, чтобы определить, какие ячейки решётки на
нашем экране оказываются задеты лучом, и приостановить алгоритм, как только луч коснется ячейки, являющейся стеной.\\

Некоторые рейтрейсеры работают с Евклидовыми углами, которые представляют направление взгляда игрока и лучей, и позволяют задать
Обзор (Поле Зрения) с помощью другого угла. Тем не менее, я обнаружил, что вместо этого намного проще работать с векторами и
камерой: положение игрока всегда является вектором (с координатами $x$ и $y$), но теперь можно также определить направление
вектора: его направление определяется с помощью двух величин (координат $x$ и $y$ направления). Вектор направления можно
визуализировать следующим образом: если нарисуем линию в направлении взгляда игрока, проходящую через точку нахождения игрока,
то каждая точка данной линии будет являться суммой показателей положения игрока и будет кратна направлению вектора (показателям
направления вектора). Длина вектора направления не имеет особого значения, важно лишь его направление. Умножение показателей
$x$ и $y$ на одну и ту же величину изменяет длину, но сохраняет направление вектора\cite{jozeph}.\\

Данный векторный метод также требует наличие дополнительного вектора, представляющего собой вектор плоскости камеры. В настоящем
3D движке также имеется плоскость камеры, и там она является настоящей 3D плоскостью, которую должны представлять два вектора
($u$ и $v$). Рейкастинг рассчитан на 2D карты, потому в этом случае плоскость камеры не является плоскостью, это скорее линия,
представленная одним вектором. Плоскость камеры всегда должна быть перпендикулярна вектору направления. Плоскость камеры
представляет собой плоскость на компьютерном экране, в то время как вектор направления расположен перпендикулярно по отношению
к этой плоскости и направлен  внутрь экрана. Положение игрока представлено одной точкой, расположенной перед плоскостью камеры.
Определённый луч определённых $x$-координат на экране является, в таком случае, лучом, который начинается в точке нахождения
игрока и проходит через это положение или через плоскость камеры.\\

На рисунке 2.6 представлена такая 2D камера. Зеленая точка - это положение (вектор $\overrightarrow{pos}$). Чёрная линия,
оканчивающаяся чёрной точкой, представляет вектор направления (вектор $\overrightarrow{dir}$). Таким образом, положение
чёрной точки  - это вектор $\overrightarrow{pos}+\overrightarrow{dir}$. Синяя линия представляет полную плоскость камеры.
Вектор, проходящий от чёрной точки к правой синей точке представляет вектор $\overrightarrow{plane}$. Таким образом,
положение правой синей точки - $\overrightarrow{pos}+\overrightarrow{dir}+\overrightarrow{plane}$, а положение левой
синей точки - $\overrightarrow{pos}+\overrightarrow{dir}-\overrightarrow{plane}$ (все это - векторное сложение).\\

Красные линии на изображении - это несколько лучей. Направление этих лучей легко можно рассчитать с помощью камеры: это - сумма
вектора направления камеры и части вектора плоскости камеры. Например, третий красный луч на рисунке проходит сквозь правую часть
плоскости камеры в точке, составляющей приблизительно $1/3$ от её длины. Таким образом, направление этого луча рассчитывается по
формуле $\overrightarrow{dir} + \overrightarrow{plane} \cdot 1/3$. Направление этого луча - это вектор $\overrightarrow{rayDir}$, а
компоненты $x$ и $y$ данного вектора далее будут использоваться в алгоритме цифрового дифференциального анализа.\\

Две другие лини являются левой и правой границей экрана, а угол между этими двумя линиями называется углом обзора. Угол обзора
 определяется по соотношению длины вектора направления и длины плоскости. Вот несколько примеров различных углов обзора:\\

Если вектор направления и вектор плоскости камеры имеют одинаковую длину, угол обзора будет равен 90°:\\

Если вектор направления намного длиннее вектора плоскости камеры, значение угла обзора будет намного меньше 90°, и поле обзора
будет очень маленьким, игрок будет видеть все более детально, но с меньшей глубиной, что напоминает приближение камеры для получения
изображения крупным планом. \\

Если вектор направления короче вектора плоскости камеры, значение угла обзора будет превышать 90° (180° - максимальная величина,
если вектор направления равен 0). В этом случае игрок будет иметь гораздо более широкое поле обзора, как при отдалении камеры. \\

При вращении игрока камера также должна вращаться(рис. 2.10), следовательно, и вектор направления, и вектор плоскости камеры также должны
поворачиваться вместе с ними. Далее все остальные лучи будут вращаться автоматически. \\

Чтобы повернуть вектор, необходимо рассчитать его по следующему шаблону вращения:\\

\begin{equation*}
\begin{vmatrix}
cos(\alpha) & -sin(\alpha)\\
sin(\alpha) & cos(\alpha)
\end{vmatrix}
\end{equation*}

К сожалению, нельзя использованию плоскость камеры, которая не перпендикулярна направлению, поскольку в результате
мы получите <<косой>>, искаженный мир.


\end{document} 